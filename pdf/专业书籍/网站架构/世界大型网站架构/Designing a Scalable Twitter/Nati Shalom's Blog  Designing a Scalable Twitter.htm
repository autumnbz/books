<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0094)http://natishalom.typepad.com/nati_shaloms_blog/2009/04/writing-your-own-scalable-twitter.html -->
<html xmlns="http://www.w3.org/1999/xhtml" id="typepad-standard" xmlns:fb="http://www.facebook.com/2008/fbml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="generator" content="http://www.typepad.com/">
	<meta name="keywords" content="GigaSpaces, Scalability, Twitter">
	<meta name="description" content="Guy Nirpaz, Uri Cohen and Shay Banon came up with an interesting exercise as part of the recent partner training that took place at the GigaSpaces office. In this exercise, the students were asked to come up with a scalable...">
	<link rel="stylesheet" href="./Nati Shalom's Blog  Designing a Scalable Twitter_files/styles.css" type="text/css" media="screen">
	<link rel="stylesheet" href="./Nati Shalom's Blog  Designing a Scalable Twitter_files/print.css" type="text/css" media="print">
	<link rel="alternate" type="application/atom+xml" title="Posts on &#39;Nati Shalom&#39;s Blog&#39; (Atom)" href="http://natishalom.typepad.com/nati_shaloms_blog/atom.xml">
	<link rel="alternate" type="application/rss+xml" title="Posts on &#39;Nati Shalom&#39;s Blog&#39; (RSS 1.0)" href="http://natishalom.typepad.com/nati_shaloms_blog/index.rdf">
	<link rel="alternate" type="application/rss+xml" title="Posts on &#39;Nati Shalom&#39;s Blog&#39; (RSS 2.0)" href="http://natishalom.typepad.com/nati_shaloms_blog/rss.xml">
	<script type="text/javascript" async="" src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/ga.js"></script><script type="text/javascript">
		var TPApp = {};
		TPApp.app_uri = "http://www.typepad.com/";
	</script>
	<script type="text/javascript" src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/flyouts-min.js"></script>
	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['t2._setAccount', 'UA-225723-36']);
		_gaq.push(['t2._setDomainName', 'none']);
		_gaq.push(['t2._setAllowLinker', true]);
        _gaq.push(['t2._setCustomVar', 1, 'Blog', '6a00d835457b7453ef00d835457b7553ef', 3]);
        _gaq.push(['t2._setCustomVar', 2, 'Page Type', 'Individual', 3]);
		_gaq.push(['t2._trackPageview']);

		(function() {
		  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
		  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>


	<style type="text/css"></style><link rel="alternate" type="application/atom+xml" title="Comments on &#39;Designing a Scalable Twitter&#39; (Atom)" href="http://natishalom.typepad.com/nati_shaloms_blog/2009/04/writing-your-own-scalable-twitter/comments/atom.xml">
	<link rel="alternate" type="application/rss+xml" title="Comments on &#39;Designing a Scalable Twitter&#39; (RSS 2.0)" href="http://natishalom.typepad.com/nati_shaloms_blog/2009/04/writing-your-own-scalable-twitter/comments/rss.xml">
	<title>Nati Shalom's Blog: Designing a Scalable Twitter</title>
	<link rel="start" href="http://natishalom.typepad.com/nati_shaloms_blog/" title="Home">
	<link rel="prev" href="http://natishalom.typepad.com/nati_shaloms_blog/2009/04/practical-guide-for-developing-enterprise-application-on-the-cloud.html?no_prefetch=1" title="Challanges for Developing Enterprise Application on the Cloud">
	<link rel="next" href="http://natishalom.typepad.com/nati_shaloms_blog/2009/05/twitter-as-a-scalability-case-study-its-the-architecture-stupid.html?no_prefetch=1" title="Twitter as a scalability case study &amp;ndash; it&amp;rsquo;s the architecture, stupid!">

</head>

<body class="layout-two-column-right post">
	
	<div id="container">
		<div id="container-inner" class="pkg">
			
			<!-- banner -->
<div id="banner">
	<div id="banner-inner" class="pkg">
		
		<h1 id="banner-header"><a href="http://natishalom.typepad.com/nati_shaloms_blog/" accesskey="1">Nati Shalom's Blog</a></h1>
		<h2 id="banner-description">
			Thoughts on Scalability, NoSQL, Big Data, DevOps, Cloud, PaaS 
		</h2>
	</div>
</div>

<div id="nav">
	<div id="nav-inner">
		<ul class="nav-list pkg">
			<li class="nav-list-item"><a href="http://natishalom.typepad.com/nati_shaloms_blog/">Home</a></li>
			<li class="nav-list-item"><a href="http://natishalom.typepad.com/nati_shaloms_blog/archives.html">Archives</a></li>
			<li class="nav-list-item"><a href="http://profile.typepad.com/natishalom">Profile</a></li>
			<li class="last-nav-list-item nav-list-item"><a href="http://natishalom.typepad.com/nati_shaloms_blog/atom.xml">Subscribe</a></li>
		</ul>
	</div>
</div>


			<div id="pagebody">
				<div id="pagebody-inner" class="pkg">
					<div id="alpha">
						<div id="alpha-inner" class="pkg">
							<script src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/jquery-1.4.2.min.js" type="text/javascript"></script>
<!-- content nav -->
<p class="content-nav">
	<a href="http://natishalom.typepad.com/nati_shaloms_blog/2009/04/practical-guide-for-developing-enterprise-application-on-the-cloud.html">« Challanges for Developing Enterprise Application on the Cloud</a> |
	<a href="http://natishalom.typepad.com/nati_shaloms_blog/">Main</a>
	| <a href="http://natishalom.typepad.com/nati_shaloms_blog/2009/05/twitter-as-a-scalability-case-study-its-the-architecture-stupid.html">Twitter as a scalability case study  its the architecture, stupid! »</a>
</p>
<script type="text/javascript">
   $(function(){
       var query = window.location.search.substring(1);
       if( query == "pintix=1" ) {
          var e=document.createElement('script');e.setAttribute('type','text/javascript');e.setAttribute('charset','UTF-8');e.setAttribute('src','http://static.typepad.com/.shared:v20130222.01-0-ga9a84f6:typepad:he//js/pinmarklet.js?r='+Math.random()*99999999);document.body.appendChild(e); 
       }
   });
</script>
<!-- entry -->
	<h2 class="date-header">April 14, 2009</h2>


<div class="entry-category-architecture entry-category-cloud_computing entry-category-compass entry-category-data_grid entry-category-gigaspaces entry-category-grid entry-category-jinijavaspaces entry-category-lucene entry-category-realtime entry-category-scalability entry-category-spacebased_architecture entry-author-nati_shalom entry-type-post entry" id="entry-65325669">
			<h3 class="entry-header">Designing a Scalable Twitter</h3>
	
	<div class="entry-content">
		<div class="entry-body">
			<p><a href="http://www.jroller.com/gnirpaz/">Guy Nirpaz</a>, <a href="http://uri-cohen.blogspot.com/">Uri Cohen</a> and <a href="http://www.kimchy.org/">Shay Banon</a> came up with an interesting exercise as part of the recent partner training that took place at the GigaSpaces office. In this exercise, the students were asked to come up with a scalable design for Twitter, using Space-Based Architecture.</p> <p>There are some interesting scalability lessons from this exercise, which are applicable to anyone looking to implement new-style real-time web applications such as the ones used for social networking.</p> <p>In this post I'll&nbsp; try to summarize the main patterns to put into place and considerations to make when designing such a scalable architecture<span style="font-weight: bold;">.</span></p><h2>Background:</h2> <p>For those of you who are not yet familiar with the service, Twitter is sort of a SMS-service meets discussion board.&nbsp; You can post short messages (up to 140 characters) that can be shared with a group of subscribers that are referred to as "followers". The main difference between twitter and other messaging applications is that both SMS and Instant Messaging (IM) applications were designed primarily for one-on-one communications whereis Twitter was designed primarily for broadcast communications (publish/subscribe, or pub/sub). Another aspect that is special about Twitter is that by default anyone can follow anyone else. In other words, it was designed for open communications, not private, as were IM and SMS.</p><h2>What are Twitter's scalability challenges?</h2> <p>1. Sending a tweet (a message on Twitter is known as a 'tweet') -– The challenge is how to handle an ever-growing volume of tweets and re-tweets and responses that can lead to a viral "message storm"</p> <p>2. Reading tweets – The challenge is how to handle a large number of concurrent users that continually “listen” for tweets from users (or topics) they follow.</p> <h2>Designing A Scalable Twitter</h2> <h3>Choosing the right scalability patterns</h3> <p>Almost every challenge in software architecture has its roots in one of the existing patterns. So the simplest course is to start by looking for those patterns, and choosing the right patterns to scale the application. Looking at <a href="http://www.typepad.com/site/blogs/6a00d835457b7453ef00d835457b7553ef/post/6a00d835457b7453ef01156f1ae981970c/edit">many other scalable architectures</a>, we'll begin with a <a href="http://en.wikipedia.org/wiki/Partition">partitioning</a> pattern as the core design principle. By partitioning our Twitter-like application we'll spread the load across a cluster of servers and scale by simply adding more servers (i.e., partitions).&nbsp; Another important architectural observation about Twitter is that it doesn’t fit into the classic database-centric design that most web applications do. On the flip side, it doesn’t fit well with a messaging-centric design (pub/sub) either. It is a combination of the two. </p> <p>A pattern that is suitable for this type of collaborative messaging is known as a <a href="http://en.wikipedia.org/wiki/Blackboard_system">blackboard pattern</a>.&nbsp; In our design, we will use those two design patterns -- partitioning and blackboard -- as the foundation for our scalable Twitter application. With the foundation in place, let’s list the requirements and examine how these patterns can be used to scale the app.</p> <h3>Scalability Requirements</h3><p> We'll assume a relatively extreme scaling requirement:</p><ul>
<li>Tweet Volume: 10 billion tweets per day </li>
<li>Tweet Storage: 100 Gigabytes per day (with 10:1 compression) </li>
</ul>
<p>Additional assumptions:</p><ul>
<li>Tweets are limited to 140 characters</li>
<li>Tweets are immutable, i.e., there are no updates, only inserts</li>
<li>Twitter limits client applications to 70 requests per hour</li>
</ul>
<p>Now that we have the foundational patterns and clear requirements, we can design the architecture. We'll start first with the blackboard system.</p> <h2>Using an In-Memory Data Grid (IMDG) as a Blackboard System</h2> <p>The are several approaches to building a blackboard system. To maximize performance and scalability, we'll store the data in memory, thus avoiding disk I/O, which is often the main cause for contention. For years, Java has provided a model for designing blackboard systems known as <a href="http://en.wikipedia.org/wiki/Tuple_space">JavaSpaces</a>. More recently, distributed caching has become popular and can provide similar capabilities to those of JavaSpaces. Let's examine two popular distributed caching approaches for our blackboard system: </p> <ol>
<li>Simple read-mostly caching using <a href="http://www.danga.com/memcached/">memcached</a> </li>
<li>Read/write caching, also known as an In-Memory Data Grid (IMDG)</li>
</ol>
 <h3>Choosing between memcached and an IMDG</h3> <p>Memcached enables us to to store the data (tweets) in a distributed memory set and read it in a scalable fashion. Having said that, be aware that memcached is not transactionally-safe and is not designed for reliability (i.e., it doesn’t support fail-over and high availability). That means that if we use memcached or something similar, we will have to use a database as the back-end. Every tweet posted will have to be written to both memcached and the database in a <strong>synchronous</strong> fashion to ensure that no tweet will be lost. This approach may be good enough for scaling read access, however, for writes and updates it offers limited scalability.</p> <p>Unlike memcached, which was designed for simple read-mostly caching, <a href="http://en.wikipedia.org/wiki/Data_grid">In-Memory Data Grids</a>&nbsp; are designed for handling a read/write scenario, and can therefore act as the system-of-record for both write and read operations. We can still use a database for long-term persistence, but because the IMDG maintains its reliability purely in memory, we can write and update the database <strong>asynchronously</strong> and avoid hitting the database bottleneck.</p> <p>Todd Hoff, author of <a href="http://www.highscalability.com/">highscalability.com</a> wrote an interesting summary that covers the different products in this space in a recent post:&nbsp; <a href="http://highscalability.com/are-cloud-based-memory-architectures-next-big-thing">Are Cloud Based Memory Architectures the Next Big</a> Thing?</p><p> Todd provide a clear explanation of how an IMDG works (using GigaSpaces):</p> <br> <blockquote><p><span style="text-decoration: underline;"><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01157044cd73970b-pi" style="display: inline;"><img alt="Nati blog 1 (2)" border="0" class="at-xid-6a00d835457b7453ef01157044cd73970b " src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/6a00d835457b7453ef01157044cd73970b-800wi" title="Nati blog 1 (2)"></a> </span> <br><span style="text-decoration: underline;"><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01156f4eabfc970c-pi" style="display: inline;"><img alt="Natiblog 2 (2)" border="0" class="at-xid-6a00d835457b7453ef01156f4eabfc970c" src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/6a00d835457b7453ef01156f4eabfc970c-800wi" title="Natiblog 2 (2)"></a> &nbsp;</span> </p><ul>
 
 <li>A <a href="http://en.wikipedia.org/wiki/POJO">POJO</a> (Plain Old Java Object) is written through a proxy using a hash-based data routing mechanism to be stored in a partition on a Processing Unit. Attributes of the object are used as a key. This is straightforward hash based partitioning like you would use with memcached. </li>
 <li>You are operating through GigaSpace's framework/container so they can automatically handle things like messaging, sending change events, replication, failover, master-worker pattern, map-reduce, transactions, parallel processing, parallel query processing, and write-behind to databases. </li>
 <li>Scaling is accomplished by dividing your objects into more partitions and assigning the partitions to Processing Unit instances which run on nodes-- a scale-out strategy. Objects are kept in RAM and the objects contain both state and behavior. A Service Grid component supports the dynamic creation and termination of Processing Units. </li>
 </ul>
 </blockquote> <p>Back to our Twitter app: Given the scalability requirements, we will need to scale both reads and writes, and therefore, an IMDG is a more suitable approach to implementing the blackboard system. </p><p>Now let’s examine how the use of an IMDG as the blackboard system enables us to scale both sending and reading tweets. Let's start by designing the partitioned cluster. </p> <h2>Designing a partition architecture </h2> <p>One of the main considerations in designing a partition cluster of any kind is determining the <strong>partition key</strong>, such as a Customer ID in a CRM application or a Trade ID in a trading application. At first glance, it sounds like a trivial decision, but choosing the right partitioning key requires a deep understanding of the application usage patterns and data model.&nbsp; In the case of Twitter, we could choose to partition the application by the data-type, the user, the tweet itself or the followers. Our first goal is selecting a key that will that will be granular enough to enable scaling the application just by adding more partitions, while making sure that we don't end up with a key that is too fine-grained -- making it sub-optimal for querying purposes. </p><p>If we use the timestamp key, for example, our application will be optimized for “inserts” (writes), however, even a simple query such “retrieve the tweets of a certain user” will force us to execute an aggregated query against all partitions. Alternatively, if we partition the data based on user-id, we'll be able to easily spread the load from different users across partitions. Retrieving the tweets of a certain user is going to be resolved in one call to a single partition. We may encounter a problem if a single user generates a significant higher load than average, however, in the case of Twitter, we can assume that this is not very likely. Partitioning by user-id is a good compromise.</p> <h3>Data capacity analysis </h3> <p>With such extreme requirements it is clear that storing all tweets in memory is going to require huge memory capacity. Very quickly this will become economically prohibitive, so we need to devise a scheme in which the IMDG acts as a buffer for most of the load on the system, and then offloads the data and queries to an underlying persistent storage.&nbsp; In our Twitter example, it is fair to assume that most real-time queries (those that require fast access to the data) will be resolved in data from the last hour or 24 hours. Queries that require older data will need to hit the database for the initial call. However, subsequent access to fetch new updates should be resolved purely in-memory. </p> <p>Using this approach, we'll need about 10 servers, each holding 10GB of data in memory to accommodate 24 hours of activity. If we also want to back up the data in memory, we will need double the amount of servers. </p> <h3>Choosing the right eviction policy</h3> <p>It's reasonable to assume that recent data is accessed most and older data is rarely used. To ensure that we get the maximum hit ratio on our memory front-end, let's choose a time-based eviction policy, which always holds the most recent updates in memory. When we will reach our memory capacity limit the oldest data will automatically get evicted from memory. The actual window of time in which we will be able to keep in memory is obviously dependent on the size of the cluster. With an IMDG implementation all tweets are stored in a persistent storage, which means that when tweets are evicted they are not deleted from the system.</p> <h2>Scaling tweet writes:</h2> <p>If we select user-id as the partitioning key, each user tweet will be sent to a specific partition. Multiple users may be routed to the same partition. Usually the algorithm to determine which partition fits a certain user is something like:</p> <p class="blockquote" style="margin-left: 40px;"><em>routing-key.hashCode() % #of partitions</em> </p><p>In GigaSpaces, this is done by marking the routing attribute of our tweet class with an <a href="http://www.gigaspaces.com/wiki/display/XAP66/POJO+Support+%28Annotations%2C+gs.xml%29+-+Advanced#POJOSupport%28Annotations%2Cgs.xml%29-Advanced-FieldLevelDecoration@SpaceRouting">@SpaceRouting</a> annotation.</p> <p>The web front-end application will call <em>space.write( new Tweet(..),..)</em>&nbsp; to send the tweets. This way there is nothing in our web client code that exposes the fact that the underlying implementation interacts with a cluster of partitions (spaces in GigaSpaces). Those details are abstracted within the space proxy. When the write method is called on the space proxy it parses the field that matches @SpaceRouting from our Tweet() object and uses this field value to calculate the partition it belongs to. It then uses that value to route the Tweet(..) object to the appropriate partition.</p> <p>With this approach, the web application can be written in a very simple way and can interact with the entire cluster as if it was a single server.</p> <p><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef011570111407970b-pi"></a><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01156f4e9d1e970c-pi" style="display: inline;"><img alt="Natiblog 3" border="0" class="at-xid-6a00d835457b7453ef01156f4e9d1e970c " src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/6a00d835457b7453ef01156f4e9d1e970c-800wi" title="Natiblog 3"></a> <br> </p> <p>The data from the memory partitions gets stored asynchronously into a persistent storage. The persistent storage could be a database, but it could also be other things, such as an index search engine based on <a href="http://www.compass-project.org/">Compass/Lucene</a>. </p> <h2>Scaling tweet reads:</h2> <p>To those familiar with messaging system, at first glance Twitter looks like a classic <a href="http://en.wikipedia.org/wiki/Publish/subscribe">publish subscribe</a> application. A closer look, however, reveals that any attempt to implement Twitter with something like a JMS message queue is going to fail in achieving a scalable system. This is especially true if you consider that the system needs to maintain a durable queue for each user. That could easily lead to a scenario in which each tweet is published to thousands of subscribers and every re-tweet can potentially lead to a "message storm".</p> <p>As <span style="text-decoration: underline;">I discuss above</span><a href="http://natishalom.typepad.com/nati_shaloms_blog/2008/05/twitter-as-an-e.html"></a>, the right way to think about this type of application is as a <a href="http://en.wikipedia.org/wiki/Blackboard_system">blackboard</a> pattern, just as a blackboard (or these days, a whiteboard) is used by a group of people (followers, in the case of Twitter) to share information and collaborate. When someone writes something on the board, everyone sees it and can choose to react. Unlike messaging (take email for example), we don’t need to send separate messages to each subscriber. Instead everyone is looking at the same board. Everything is also copied from the board to paper. When the board runs out of space, we erase it. And we can always page through the paper copy to access the board history.&nbsp; </p> <p>In Twitter, this means that each follower that follows a group of people is basically polling for messages posted by those users from the last time he read them. To make things more tangible we can express this type of query with the following SQL syntax:</p><p class="blockquote" style="margin-left: 40px;"> <em>SELECT * FROM Post WHERE UserID=&lt;id&gt; AND PostedOn &gt; &lt;from date&gt;</em><strong>.</strong></p><p><strong> </strong>The <em>&lt;from date&gt;</em> will normally be the last few minutes, if we're constantly looking for new messages. </p><p>But there's a caveat. Remember that we partitioned the application by user-id? This means that each user's tweets are stored in a separate partition. How can we read all users' posts? If we poll for each user individually, we will end up with a lot of network calls. The simplest approach would be to execute one call that looks for ALL the users we're following and look for updates (new tweets) from those users. The pattern we'll use to perform such this task is <a href="http://natishalom.typepad.com/nati_shaloms_blog/2008/10/is-mapreduce-going-to-main-stream.html">mapreduce</a>. One way to do that with GigaSpaces is through the <a href="http://www.gigaspaces.com/wiki/display/XAP7/Executors+Component#ExecutorsComponent-DistributedTaskAPI">distributed task API</a>:</p> <p><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01157011c08e970b-pi"></a><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01156f4e9f3b970c-pi" style="display: inline;"><img alt="Nati blog 4" border="0" class="at-xid-6a00d835457b7453ef01156f4e9f3b970c " src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/6a00d835457b7453ef01156f4e9f3b970c-800wi" title="Nati blog 4"></a> <br> </p> <p>The distributed task API is a modern version of the stored procedure. The following snippet shows what such a call would look like:</p> <blockquote> <pre><em>AsyncFuture&lt;Long&gt; future = gigaSpace.execute(new GetTweetsUpdates());<br>long result = future.get(); // result will be the number of primary spaces</em></pre>
</blockquote>

<p>The GetTweetsUpdates() class contains code that will be injected in each partition and will enable us to look for updates from the users we follow in a single call. Because the call runs in-process, and because the data is stored in-memory, executing such a task is extremely fast compared with the equivalent with database and stored procedure operations. Execution is aggregated to the caller implicitly. The caller can use a <a href="http://www.gigaspaces.com/wiki/display/XAP7/Executors+Component#ExecutorsComponent-BuiltinReducers">reducer</a> to aggregate the results into a single result object.</p>

<h2>Scaling the web front-end</h2>

<p>Nothing really new here. We'll use a classic web front-end, which is comprised of a load-balancer and a cluster of web servers that act as a front end to our IMDG instances. The web application will use a single cluster-aware IMDG proxy to send new tweet posts. The IMDG proxy will be responsible for mapping the tweet with the actual partition that hosting the tweet. That logic is kept completely out of the application code. This allows us to keep our web tier clean and simple.</p>

<h3>Keeping the web layer stateless to avoid session stickiness</h3>

<p>One common pattern for keeping the web tier scalable is to use a <a href="http://blog.gigaspaces.com/2007/04/06/shared-nothing-architecture-redefined/">Shared-Nothing Architecture</a>, which basically means that the web tier will be stateless. This requires keeping the user session state external to the web-tier. As previously demonstrated, the IMDG can be used as high-performance, scalable data store for maintaining shared session state information. This allows us to avoid session stickiness and to scale the web tier without being locked in to a specific server throughout the entire session, in case the server is over-loaded.</p>

<p>For more information on how to scale the web tier, as well as other important capabilities such as self-healing and auto-scaling, see the following tutorial: <a href="http://www.gigaspaces.com/wiki/display/XAP66/Scaling+Your+Web+Application">Scaling Your Web Application</a>.</p>

<h2>Making it simple and cost-effective using cloud computing</h2>

<p>Twitter is yet another example for a situation in which system load is highly variable and the difference between average load and peak load can be quite significant. In such cases, provisioning our system can be fairly hard and costly. This is where cloud computing and SLA-driven deployments can help us scale on demand and pay only for what we use. </p>

<p>Once we figured out a way to partition the application, it's going to be much simpler to package the application into self-sufficient units (referred to in GigaSpaces as processing-units) and scale the application simply by adding or removing these units on demand. You can learn more about this <a href="http://natishalom.typepad.com/nati_shaloms_blog/2009/03/its-time-for-auto-scaling-avoid-peak-load-provisioning.html">here</a></p>

<h2>Final words</h2>

<p>Scaling a real-time web application such as Twitter or Facebook introduces unique challenges that are are quite different from those of a "classic" database-centric application. The most profound difference is the fact that unlike with traditional sites, Twitter is a heavy read/write application, and not read-mostly. This seemingly minor difference can break most existing models for web application scalability. Using a combination of memcached + MySQL is not going to cut it for this type of application.&nbsp; </p>

<p>The good news is that with the right patterns and set of tools, building a scalable architecture that meets such challenges isn’t that difficult.&nbsp; There are already plenty of success stories that demonstrate that, such as the following example from highscalability.com: <a href="http://highscalability.com/handle-1-billion-events-day-using-memory-grid">Handle 1 Billion Events Per Day Using a Memory Grid</a></p>

<p>The proposed architecture is by no means perfect and can be further optimized to meet even better performance and latency, but that will come at the cost of simplicity. I believe that the proposed architecture should get you pretty far as-is. Avoid going through more advanced optimizations until the point they are an absolute must.<span style="font-weight: bold;"><strong> <br></strong></span></p><p><span style="font-weight: bold;"><strong> </strong><br></span></p><h2>References</h2>

<ul>
 <li>
 <h4><a href="http://vehera.jsn-server7.com/LiddleBlog/?p=315">Twitter getting bigger - Scaling becomes more of an issue</a></h4>
 </li>
 <li>
 <h4><a href="http://gevaperry.typepad.com/main/2009/03/memorybased-architectures-and-the-cloud.html">Memory-Based Architectures and the Cloud</a></h4>
 </li>
 <li>
 <h4><a href="http://highscalability.com/handle-1-billion-events-day-using-memory-grid">Handle 1 Billion Events Per Day Using a Memory Grid</a></h4>
 </li>
 <li>
 <h4><a href="http://highscalability.com/are-cloud-based-memory-architectures-next-big-thing">Are Cloud-Based Memory Architectures the Next Big Thing?</a></h4>
 </li>
 <li>
 <h4><a href="http://www.gigaspaces.com/wiki/display/XAP66/Scaling+Your+Web+Application">Scaling Your Web Application</a></h4>
 </li>
 <li>
 <h4><a href="http://blog.gigaspaces.com/2009/04/02/persistence-on-the-cloud-%e2%80%93-how-and-why/">Persistence on the Cloud – How and Why?</a></h4>
 </li>
 <li><strong><a href="http://www.jroller.com/gnirpaz/entry/my_sdc_presentation">Scaling twitter presentation by Guy Nirpaz</a></strong></li>
</ul>
		</div>
		
					<script src="http://feeds.feedburner.com/~s/NatiShalom?i=http%3A%2F%2Fnatishalom.typepad.com%2Fnati_shaloms_blog%2F2009%2F04%2Fwriting-your-own-scalable-twitter.html" type="text/javascript"></script>
		
	</div>
	<div class="entry-footer">
			<p class="entry-footer-info">
				<span class="post-footers">Posted at 09:45 PM in <a href="http://natishalom.typepad.com/nati_shaloms_blog/architecture/">Architecture</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/cloud_computing/">Cloud Computing</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/compass/">Compass</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/data-grid/">Data Grid</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/gigaspaces/">GigaSpaces</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/grid/">Grid</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/jinijavaspaces/">Jini/JavaSpaces</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/lucene/">Lucene</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/real-time/">real-time</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/scalability/">scalability</a>, <a href="http://natishalom.typepad.com/nati_shaloms_blog/spacebased_architecture/">Space-Based Architecture</a> </span> <span class="separator">|</span> <a class="permalink" href="./Nati Shalom's Blog  Designing a Scalable Twitter_files/Nati Shalom's Blog  Designing a Scalable Twitter.htm">Permalink</a>
			</p>
		
		<!-- technorati tags -->
			<p class="entry-footer-tags">
			<a href="http://www.technorati.com/search/http://natishalom.typepad.com/nati_shaloms_blog/2009/04/writing-your-own-scalable-twitter.html" title="Find related items at Technorati.">Technorati Tags</a>:
			<a href="http://technorati.com/tag/GigaSpaces" rel="tag">GigaSpaces</a>, <a href="http://technorati.com/tag/Scalability" rel="tag">Scalability</a>, <a href="http://technorati.com/tag/Twitter" rel="tag">Twitter</a>
		</p>
	


		<!-- post footer links -->
	<p class="entry-footer-share entry-footer-share-buttons">
		<span class="entry-footer-links-favorite"><iframe class="favorite" id="favbutton-6a00d835457b7453ef01156f1ae981970c" name="favbutton-6a00d835457b7453ef01156f1ae981970c" src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/favorite.htm" frameborder="0" scrolling="no" marginheight="0" marginwidth="0"></iframe></span> <span class="separator">|</span> <span class="entry-footer-links-reblog"><a href="http://natishalom.typepad.com/nati_shaloms_blog/2009/04/writing-your-own-scalable-twitter.html#" class="share-link share-link-reblog" title="Grab this post for your own blog" onclick="b=document.body; TYPEPAD___bookmarklet_domain=&#39;http://www.typepad.com/&#39;; TYPEPAD___reblog_entryxid=&#39;6a00d835457b7453ef01156f1ae981970c&#39;; TYPEPAD___is_reblog = 1; if (b &amp;&amp; !document.xmlVersion) { void ( z=document.createElement(&#39;script&#39;)); void(z.type=&#39;text/javascript&#39;); void(z.src=&#39;http://static.typepad.com/.shared:v20130222.01-0-ga9a84f6:typepad:he/js/qp/loader-combined-min.js&#39;); void(b.appendChild(z));}else{}">Reblog
 (0)
</a>
</span>
	</p>


	</div>
</div>

		<div class="trackbacks">
		<a id="trackback"></a>
		<h3 class="trackbacks-header">TrackBack</h3>
		<div class="trackbacks-info">
			<p>TrackBack URL for this entry:<br><span class="trackbacks-link">http://www.typepad.com/services/trackback/6a00d835457b7453ef01156f1ae981970c</span></p>
			<p>Listed below are links to weblogs that reference <a href="./Nati Shalom's Blog  Designing a Scalable Twitter_files/Nati Shalom's Blog  Designing a Scalable Twitter.htm">Designing a Scalable Twitter</a>:</p>
		</div>
		<div class="trackbacks-content">
			
		</div>
	</div>







        
        <a id="comments"></a>
        <h3 class="comments-header">Comments</h3>
<div class="comments-content">
        <div id="tpc_thread"></div>
        <div style="display:none;" id="tpc_post_title">Designing a Scalable Twitter</div>
        <div style="display:none;" id="tpc_post_message"><p><a href="http://www.jroller.com/gnirpaz/">Guy Nirpaz</a>, <a href="http://uri-cohen.blogspot.com/">Uri Cohen</a> and <a href="http://www.kimchy.org/">Shay Banon</a> came up with an interesting exercise as part of the recent partner training that took place at the GigaSpaces office. In this exercise, the students were asked to come up with a scalable design for Twitter, using Space-Based Architecture.</p> <p>There are some interesting scalability lessons from this exercise, which are applicable to anyone looking to implement new-style real-time web applications such as the ones used for social networking.</p> <p>In this post I'll&nbsp; try to summarize the main patterns to put into place and considerations to make when designing such a scalable architecture<span style="font-weight: bold;">.</span></p><h2>Background:</h2> <p>For those of you who are not yet familiar with the service, Twitter is sort of a SMS-service meets discussion board.&nbsp; You can post short messages (up to 140 characters) that can be shared with a group of subscribers that are referred to as "followers". The main difference between twitter and other messaging applications is that both SMS and Instant Messaging (IM) applications were designed primarily for one-on-one communications whereis Twitter was designed primarily for broadcast communications (publish/subscribe, or pub/sub). Another aspect that is special about Twitter is that by default anyone can follow anyone else. In other words, it was designed for open communications, not private, as were IM and SMS.</p><h2>What are Twitter's scalability challenges?</h2> <p>1. Sending a tweet (a message on Twitter is known as a 'tweet') -– The challenge is how to handle an ever-growing volume of tweets and re-tweets and responses that can lead to a viral "message storm"</p> <p>2. Reading tweets – The challenge is how to handle a large number of concurrent users that continually “listen” for tweets from users (or topics) they follow.</p> <h2>Designing A Scalable Twitter</h2> <h3>Choosing the right scalability patterns</h3> <p>Almost every challenge in software architecture has its roots in one of the existing patterns. So the simplest course is to start by looking for those patterns, and choosing the right patterns to scale the application. Looking at <a href="http://www.typepad.com/site/blogs/6a00d835457b7453ef00d835457b7553ef/post/6a00d835457b7453ef01156f1ae981970c/edit">many other scalable architectures</a>, we'll begin with a <a href="http://en.wikipedia.org/wiki/Partition">partitioning</a> pattern as the core design principle. By partitioning our Twitter-like application we'll spread the load across a cluster of servers and scale by simply adding more servers (i.e., partitions).&nbsp; Another important architectural observation about Twitter is that it doesn’t fit into the classic database-centric design that most web applications do. On the flip side, it doesn’t fit well with a messaging-centric design (pub/sub) either. It is a combination of the two. </p> <p>A pattern that is suitable for this type of collaborative messaging is known as a <a href="http://en.wikipedia.org/wiki/Blackboard_system">blackboard pattern</a>.&nbsp; In our design, we will use those two design patterns -- partitioning and blackboard -- as the foundation for our scalable Twitter application. With the foundation in place, let’s list the requirements and examine how these patterns can be used to scale the app.</p> <h3>Scalability Requirements</h3><p> We'll assume a relatively extreme scaling requirement:</p><ul>
<li>Tweet Volume: 10 billion tweets per day </li>
<li>Tweet Storage: 100 Gigabytes per day (with 10:1 compression) </li>
</ul>
<p>Additional assumptions:</p><ul>
<li>Tweets are limited to 140 characters</li>
<li>Tweets are immutable, i.e., there are no updates, only inserts</li>
<li>Twitter limits client applications to 70 requests per hour</li>
</ul>
<p>Now that we have the foundational patterns and clear requirements, we can design the architecture. We'll start first with the blackboard system.</p> <h2>Using an In-Memory Data Grid (IMDG) as a Blackboard System</h2> <p>The are several approaches to building a blackboard system. To maximize performance and scalability, we'll store the data in memory, thus avoiding disk I/O, which is often the main cause for contention. For years, Java has provided a model for designing blackboard systems known as <a href="http://en.wikipedia.org/wiki/Tuple_space">JavaSpaces</a>. More recently, distributed caching has become popular and can provide similar capabilities to those of JavaSpaces. Let's examine two popular distributed caching approaches for our blackboard system: </p> <ol>
<li>Simple read-mostly caching using <a href="http://www.danga.com/memcached/">memcached</a> </li>
<li>Read/write caching, also known as an In-Memory Data Grid (IMDG)</li>
</ol>
 <h3>Choosing between memcached and an IMDG</h3> <p>Memcached enables us to to store the data (tweets) in a distributed memory set and read it in a scalable fashion. Having said that, be aware that memcached is not transactionally-safe and is not designed for reliability (i.e., it doesn’t support fail-over and high availability). That means that if we use memcached or something similar, we will have to use a database as the back-end. Every tweet posted will have to be written to both memcached and the database in a <strong>synchronous</strong> fashion to ensure that no tweet will be lost. This approach may be good enough for scaling read access, however, for writes and updates it offers limited scalability.</p> <p>Unlike memcached, which was designed for simple read-mostly caching, <a href="http://en.wikipedia.org/wiki/Data_grid">In-Memory Data Grids</a>&nbsp; are designed for handling a read/write scenario, and can therefore act as the system-of-record for both write and read operations. We can still use a database for long-term persistence, but because the IMDG maintains its reliability purely in memory, we can write and update the database <strong>asynchronously</strong> and avoid hitting the database bottleneck.</p> <p>Todd Hoff, author of <a href="http://www.highscalability.com/">highscalability.com</a> wrote an interesting summary that covers the different products in this space in a recent post:&nbsp; <a href="http://highscalability.com/are-cloud-based-memory-architectures-next-big-thing">Are Cloud Based Memory Architectures the Next Big</a> Thing?</p><p> Todd provide a clear explanation of how an IMDG works (using GigaSpaces):</p> <br> <blockquote><p><span style="text-decoration: underline;"><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01157044cd73970b-pi" style="display: inline;"><img alt="Nati blog 1 (2)" border="0" class="at-xid-6a00d835457b7453ef01157044cd73970b " src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/6a00d835457b7453ef01157044cd73970b-800wi" title="Nati blog 1 (2)"></a> </span> <br><span style="text-decoration: underline;"><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01156f4eabfc970c-pi" style="display: inline;"><img alt="Natiblog 2 (2)" border="0" class="at-xid-6a00d835457b7453ef01156f4eabfc970c" src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/6a00d835457b7453ef01156f4eabfc970c-800wi" title="Natiblog 2 (2)"></a> &nbsp;</span> </p><ul>
 
 <li>A <a href="http://en.wikipedia.org/wiki/POJO">POJO</a> (Plain Old Java Object) is written through a proxy using a hash-based data routing mechanism to be stored in a partition on a Processing Unit. Attributes of the object are used as a key. This is straightforward hash based partitioning like you would use with memcached. </li>
 <li>You are operating through GigaSpace's framework/container so they can automatically handle things like messaging, sending change events, replication, failover, master-worker pattern, map-reduce, transactions, parallel processing, parallel query processing, and write-behind to databases. </li>
 <li>Scaling is accomplished by dividing your objects into more partitions and assigning the partitions to Processing Unit instances which run on nodes-- a scale-out strategy. Objects are kept in RAM and the objects contain both state and behavior. A Service Grid component supports the dynamic creation and termination of Processing Units. </li>
 </ul>
 </blockquote> <p>Back to our Twitter app: Given the scalability requirements, we will need to scale both reads and writes, and therefore, an IMDG is a more suitable approach to implementing the blackboard system. </p><p>Now let’s examine how the use of an IMDG as the blackboard system enables us to scale both sending and reading tweets. Let's start by designing the partitioned cluster. </p> <h2>Designing a partition architecture </h2> <p>One of the main considerations in designing a partition cluster of any kind is determining the <strong>partition key</strong>, such as a Customer ID in a CRM application or a Trade ID in a trading application. At first glance, it sounds like a trivial decision, but choosing the right partitioning key requires a deep understanding of the application usage patterns and data model.&nbsp; In the case of Twitter, we could choose to partition the application by the data-type, the user, the tweet itself or the followers. Our first goal is selecting a key that will that will be granular enough to enable scaling the application just by adding more partitions, while making sure that we don't end up with a key that is too fine-grained -- making it sub-optimal for querying purposes. </p><p>If we use the timestamp key, for example, our application will be optimized for “inserts” (writes), however, even a simple query such “retrieve the tweets of a certain user” will force us to execute an aggregated query against all partitions. Alternatively, if we partition the data based on user-id, we'll be able to easily spread the load from different users across partitions. Retrieving the tweets of a certain user is going to be resolved in one call to a single partition. We may encounter a problem if a single user generates a significant higher load than average, however, in the case of Twitter, we can assume that this is not very likely. Partitioning by user-id is a good compromise.</p> <h3>Data capacity analysis </h3> <p>With such extreme requirements it is clear that storing all tweets in memory is going to require huge memory capacity. Very quickly this will become economically prohibitive, so we need to devise a scheme in which the IMDG acts as a buffer for most of the load on the system, and then offloads the data and queries to an underlying persistent storage.&nbsp; In our Twitter example, it is fair to assume that most real-time queries (those that require fast access to the data) will be resolved in data from the last hour or 24 hours. Queries that require older data will need to hit the database for the initial call. However, subsequent access to fetch new updates should be resolved purely in-memory. </p> <p>Using this approach, we'll need about 10 servers, each holding 10GB of data in memory to accommodate 24 hours of activity. If we also want to back up the data in memory, we will need double the amount of servers. </p> <h3>Choosing the right eviction policy</h3> <p>It's reasonable to assume that recent data is accessed most and older data is rarely used. To ensure that we get the maximum hit ratio on our memory front-end, let's choose a time-based eviction policy, which always holds the most recent updates in memory. When we will reach our memory capacity limit the oldest data will automatically get evicted from memory. The actual window of time in which we will be able to keep in memory is obviously dependent on the size of the cluster. With an IMDG implementation all tweets are stored in a persistent storage, which means that when tweets are evicted they are not deleted from the system.</p> <h2>Scaling tweet writes:</h2> <p>If we select user-id as the partitioning key, each user tweet will be sent to a specific partition. Multiple users may be routed to the same partition. Usually the algorithm to determine which partition fits a certain user is something like:</p> <p class="blockquote" style="margin-left: 40px;"><em>routing-key.hashCode() % #of partitions</em> </p><p>In GigaSpaces, this is done by marking the routing attribute of our tweet class with an <a href="http://www.gigaspaces.com/wiki/display/XAP66/POJO+Support+%28Annotations%2C+gs.xml%29+-+Advanced#POJOSupport%28Annotations%2Cgs.xml%29-Advanced-FieldLevelDecoration@SpaceRouting">@SpaceRouting</a> annotation.</p> <p>The web front-end application will call <em>space.write( new Tweet(..),..)</em>&nbsp; to send the tweets. This way there is nothing in our web client code that exposes the fact that the underlying implementation interacts with a cluster of partitions (spaces in GigaSpaces). Those details are abstracted within the space proxy. When the write method is called on the space proxy it parses the field that matches @SpaceRouting from our Tweet() object and uses this field value to calculate the partition it belongs to. It then uses that value to route the Tweet(..) object to the appropriate partition.</p> <p>With this approach, the web application can be written in a very simple way and can interact with the entire cluster as if it was a single server.</p> <p><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef011570111407970b-pi"></a><a href="http://natishalom.typepad.com/.a/6a00d835457b7453ef01156f4e9d1e970c-pi" style="display: inline;"><img alt="Natiblog 3" border="0" class="at-xid-6a00d835457b7453ef01156f4e9d1e970c " src="./Nati Shalom's Blog  Designing a Scalable Twitter_files/6a00d835457b7453ef01156f4e9d1e970c-800wi" title="Natiblog 3"></a> <br> </p> <p>The data from the memory partitions gets stored asynchronously into a persistent storage. The persistent storage could be a database, but it could also be other things, such as an index search engine based on <a href="http://www.compass-project.org/">Compass/Lucene</a>. </p> <h2>Scaling tweet reads:</h2> <p>To those familiar with messaging system, at first glance Twitter looks like a classic <a href="http://en.wikipedia.org/wiki/Publish/subscribe">publish subscribe</a> application. A closer look, however, reveals that any attempt to implement Twitter with something like a JMS message queue is going to fail in achieving a scalable system. This is especially true if you consider that the system needs to maintain a durable queue for each user. That could easily lead to a scenario in which each tweet </p></div></div></div></div></div></div></div></div></body></html>