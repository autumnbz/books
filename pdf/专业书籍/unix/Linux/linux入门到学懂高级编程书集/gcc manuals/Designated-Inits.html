<html lang="en">
<head>
<title>Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.6">
<!--
Copyright &copy; 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   <p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding
Free Software", the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   <p>(a) The FSF's Front-Cover Text is:

   <p>A GNU Manual

   <p>(b) The FSF's Back-Cover Text is:

   <p>You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="Designated%20Inits">Designated Inits</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="Cast-to-Union.html#Cast%20to%20Union">Cast to Union</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Compound-Literals.html#Compound%20Literals">Compound Literals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="C-Extensions.html#C%20Extensions">C Extensions</a>
<hr><br>
</div>

<h3 class="section">Designated Initializers</h3>

<p>Standard C89 requires the elements of an initializer to appear in a fixed
order, the same as the order of the elements in the array or structure
being initialized.

   <p>In ISO C99 you can give the elements in any order, specifying the array
indices or structure field names they apply to, and GNU C allows this as
an extension in C89 mode as well.  This extension is not
implemented in GNU C++.

   <p>To specify an array index, write
<code>[</code><var>index</var><code>] =</code> before the element value.  For example,

<pre class="smallexample">     int a[6] = { [4] = 29, [2] = 15 };
     </pre>

<p>is equivalent to

<pre class="smallexample">     int a[6] = { 0, 0, 15, 0, 29, 0 };
     </pre>

<p>The index values must be constant expressions, even if the array being
initialized is automatic.

   <p>An alternative syntax for this which has been obsolete since GCC 2.5 but
GCC still accepts is to write <code>[</code><var>index</var><code>]</code> before the element
value, with no <code>=</code>.

   <p>To initialize a range of elements to the same value, write
<code>[</code><var>first</var><code> ... </code><var>last</var><code>] = </code><var>value</var><code></code>.  This is a GNU
extension.  For example,

<pre class="smallexample">     int widths[] = { [0 ... 9] = 1, [10 ... 99] = 2, [100] = 3 };
     </pre>

<p>If the value in it has side-effects, the side-effects will happen only once,
not for each initialized field by the range initializer.

<p>Note that the length of the array is the highest value specified
plus one.

   <p>In a structure initializer, specify the name of a field to initialize
with <code>.</code><var>fieldname</var><code> =</code> before the element value.  For example,
given the following structure,

<pre class="smallexample">     struct point { int x, y; };
     </pre>

<p>the following initialization

<pre class="smallexample">     struct point p = { .y = yvalue, .x = xvalue };
     </pre>

<p>is equivalent to

<pre class="smallexample">     struct point p = { xvalue, yvalue };
     </pre>

   <p>Another syntax which has the same meaning, obsolete since GCC 2.5, is
<code></code><var>fieldname</var><code>:</code>, as shown here:

<pre class="smallexample">     struct point p = { y: yvalue, x: xvalue };
     </pre>

   <p>The <code>[</code><var>index</var><code>]</code> or <code>.</code><var>fieldname</var><code></code> is known as a
<dfn>designator</dfn>.  You can also use a designator (or the obsolete colon
syntax) when initializing a union, to specify which element of the union
should be used.  For example,

<pre class="smallexample">     union foo { int i; double d; };
     
     union foo f = { .d = 4 };
     </pre>

<p>will convert 4 to a <code>double</code> to store it in the union using
the second element.  By contrast, casting 4 to type <code>union foo</code>
would store it into the union as the integer <code>i</code>, since it is
an integer.  (See <a href="Cast-to-Union.html#Cast%20to%20Union">Cast to Union</a>.)

   <p>You can combine this technique of naming elements with ordinary C
initialization of successive elements.  Each initializer element that
does not have a designator applies to the next consecutive element of the
array or structure.  For example,

<pre class="smallexample">     int a[6] = { [1] = v1, v2, [4] = v4 };
     </pre>

<p>is equivalent to

<pre class="smallexample">     int a[6] = { 0, v1, v2, 0, v4, 0 };
     </pre>

   <p>Labeling the elements of an array initializer is especially useful
when the indices are characters or belong to an <code>enum</code> type. 
For example:

<pre class="smallexample">     int whitespace[256]
       = { [' '] = 1, ['\t'] = 1, ['\h'] = 1,
           ['\f'] = 1, ['\n'] = 1, ['\r'] = 1 };
     </pre>

   <p>You can also write a series of <code>.</code><var>fieldname</var><code></code> and
<code>[</code><var>index</var><code>]</code> designators before an <code>=</code> to specify a
nested subobject to initialize; the list is taken relative to the
subobject corresponding to the closest surrounding brace pair.  For
example, with the <code>struct point</code> declaration above:

<pre class="smallexample">     struct point ptarray[10] = { [2].y = yv2, [2].x = xv2, [0].x = xv0 };
     </pre>

<p>If the same field is initialized multiple times, it will have value from
the last initialization.  If any such overridden initialization has
side-effect, it is unspecified whether the side-effect happens or not. 
Currently, GCC will discard them and issue a warning.

   </body></html>

