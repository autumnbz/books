<html lang="en">
<head>
<title>Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.6">
<!--
Copyright &copy; 1988, 1989, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

   <p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with the
Invariant Sections being "GNU General Public License" and "Funding
Free Software", the Front-Cover texts being (a) (see below), and with
the Back-Cover Texts being (b) (see below).  A copy of the license is
included in the section entitled "GNU Free Documentation License".

   <p>(a) The FSF's Front-Cover Text is:

   <p>A GNU Manual

   <p>(b) The FSF's Back-Cover Text is:

   <p>You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
--></style>
</head>
<body>
<div class="node">
<p>
Node:&nbsp;<a name="ARM%20Options">ARM Options</a>,
Next:&nbsp;<a rel="next" accesskey="n" href="MN10300-Options.html#MN10300%20Options">MN10300 Options</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="SPARC-Options.html#SPARC%20Options">SPARC Options</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Submodel-Options.html#Submodel%20Options">Submodel Options</a>
<hr><br>
</div>

<h3 class="subsection">ARM Options</h4>

<p>These <code>-m</code> options are defined for Advanced RISC Machines (ARM)
architectures:

     <dl>
<dt><code>-mabi=</code><var>name</var><code></code>
     <dd>Generate code for the specified ABI.  Permissible values are: <code>apcs-gnu</code>,
<code>atpcs</code>, <code>aapcs</code> and <code>iwmmxt</code>.

     <br><dt><code>-mapcs-frame</code>
     <dd>Generate a stack frame that is compliant with the ARM Procedure Call
Standard for all functions, even if this is not strictly necessary for
correct execution of the code.  Specifying <code>-fomit-frame-pointer</code>
with this option will cause the stack frames not to be generated for
leaf functions.  The default is <code>-mno-apcs-frame</code>.

     <br><dt><code>-mapcs</code>
     <dd>This is a synonym for <code>-mapcs-frame</code>.

     <br><dt><code>-mapcs-26</code>
     <dd>Generate code for a processor running with a 26-bit program counter,
and conforming to the function calling standards for the APCS 26-bit
option.  This option replaces the <code>-m2</code> and <code>-m3</code> options
of previous releases of the compiler.

     <br><dt><code>-mapcs-32</code>
     <dd>Generate code for a processor running with a 32-bit program counter,
and conforming to the function calling standards for the APCS 32-bit
option.  This option replaces the <code>-m6</code> option of previous releases
of the compiler.

     <br><dt><code>-mthumb-interwork</code>
     <dd>Generate code which supports calling between the ARM and Thumb
instruction sets.  Without this option the two instruction sets cannot
be reliably used inside one program.  The default is
<code>-mno-thumb-interwork</code>, since slightly larger code is generated
when <code>-mthumb-interwork</code> is specified.

     <br><dt><code>-mno-sched-prolog</code>
     <dd>Prevent the reordering of instructions in the function prolog, or the
merging of those instruction with the instructions in the function's
body.  This means that all functions will start with a recognizable set
of instructions (or in fact one of a choice from a small set of
different function prologues), and this information can be used to
locate the start if functions inside an executable piece of code.  The
default is <code>-msched-prolog</code>.

     <br><dt><code>-mhard-float</code>
     <dd>Generate output containing floating point instructions.  This is the
default.

     <br><dt><code>-msoft-float</code>
     <dd>Generate output containing library calls for floating point. 
<strong>Warning:</strong> the requisite libraries are not available for all ARM
targets.  Normally the facilities of the machine's usual C compiler are
used, but this cannot be done directly in cross-compilation.  You must make
your own arrangements to provide suitable library functions for
cross-compilation.

     <p><code>-msoft-float</code> changes the calling convention in the output file;
therefore, it is only useful if you compile <em>all</em> of a program with
this option.  In particular, you need to compile <code>libgcc.a</code>, the
library that comes with GCC, with <code>-msoft-float</code> in order for
this to work.

     <br><dt><code>-mfloat-abi=</code><var>name</var><code></code>
     <dd>Specifies which ABI to use for floating point values.  Permissible values
are: <code>soft</code>, <code>softfp</code> and <code>hard</code>.

     <p><code>soft</code> and <code>hard</code> are equivalent to <code>-msoft-float</code>
and <code>-mhard-float</code> respectively.  <code>softfp</code> allows the generation
of floating point instructions, but still uses the soft-float calling
conventions.

     <br><dt><code>-mlittle-endian</code>
     <dd>Generate code for a processor running in little-endian mode.  This is
the default for all standard configurations.

     <br><dt><code>-mbig-endian</code>
     <dd>Generate code for a processor running in big-endian mode; the default is
to compile code for a little-endian processor.

     <br><dt><code>-mwords-little-endian</code>
     <dd>This option only applies when generating code for big-endian processors. 
Generate code for a little-endian word order but a big-endian byte
order.  That is, a byte order of the form <code>32107654</code>.  Note: this
option should only be used if you require compatibility with code for
big-endian ARM processors generated by versions of the compiler prior to
2.8.

     <br><dt><code>-malignment-traps</code>
     <dd>Generate code that will not trap if the MMU has alignment traps enabled. 
On ARM architectures prior to ARMv4, there were no instructions to
access half-word objects stored in memory.  However, when reading from
memory a feature of the ARM architecture allows a word load to be used,
even if the address is unaligned, and the processor core will rotate the
data as it is being loaded.  This option tells the compiler that such
misaligned accesses will cause a MMU trap and that it should instead
synthesize the access as a series of byte accesses.  The compiler can
still use word accesses to load half-word data if it knows that the
address is aligned to a word boundary.

     <p>This option is ignored when compiling for ARM architecture 4 or later,
since these processors have instructions to directly access half-word
objects in memory.

     <br><dt><code>-mno-alignment-traps</code>
     <dd>Generate code that assumes that the MMU will not trap unaligned
accesses.  This produces better code when the target instruction set
does not have half-word memory operations (i.e. implementations prior to
ARMv4).

     <p>Note that you cannot use this option to access unaligned word objects,
since the processor will only fetch one 32-bit aligned object from
memory.

     <p>The default setting for most targets is <code>-mno-alignment-traps</code>, since
this produces better code when there are no half-word memory
instructions available.

     <br><dt><code>-mshort-load-bytes</code>
     <dd><dt><code>-mno-short-load-words</code>
     <dd>These are deprecated aliases for <code>-malignment-traps</code>.

     <br><dt><code>-mno-short-load-bytes</code>
     <dd><dt><code>-mshort-load-words</code>
     <dd>This are deprecated aliases for <code>-mno-alignment-traps</code>.

     <br><dt><code>-mcpu=</code><var>name</var><code></code>
     <dd>This specifies the name of the target ARM processor.  GCC uses this name
to determine what kind of instructions it can emit when generating
assembly code.  Permissible names are: <code>arm2</code>, <code>arm250</code>,
<code>arm3</code>, <code>arm6</code>, <code>arm60</code>, <code>arm600</code>, <code>arm610</code>,
<code>arm620</code>, <code>arm7</code>, <code>arm7m</code>, <code>arm7d</code>, <code>arm7dm</code>,
<code>arm7di</code>, <code>arm7dmi</code>, <code>arm70</code>, <code>arm700</code>,
<code>arm700i</code>, <code>arm710</code>, <code>arm710c</code>, <code>arm7100</code>,
<code>arm7500</code>, <code>arm7500fe</code>, <code>arm7tdmi</code>, <code>arm8</code>,
<code>strongarm</code>, <code>strongarm110</code>, <code>strongarm1100</code>,
<code>arm8</code>, <code>arm810</code>, <code>arm9</code>, <code>arm9e</code>, <code>arm920</code>,
<code>arm920t</code>, <code>arm926ejs</code>, <code>arm940t</code>, <code>arm9tdmi</code>,
<code>arm10tdmi</code>, <code>arm1020t</code>, <code>arm1026ejs</code>,
<code>arm1136js</code>, <code>arm1136jfs</code> ,<code>xscale</code>, <code>iwmmxt</code>,
<code>ep9312</code>.

     <dt><code>-mtune=</code><var>name</var><code></code>
     <dd>This option is very similar to the <code>-mcpu=</code> option, except that
instead of specifying the actual target processor type, and hence
restricting which instructions can be used, it specifies that GCC should
tune the performance of the code as if the target were of the type
specified in this option, but still choosing the instructions that it
will generate based on the cpu specified by a <code>-mcpu=</code> option. 
For some ARM implementations better performance can be obtained by using
this option.

     <br><dt><code>-march=</code><var>name</var><code></code>
     <dd>This specifies the name of the target ARM architecture.  GCC uses this
name to determine what kind of instructions it can emit when generating
assembly code.  This option can be used in conjunction with or instead
of the <code>-mcpu=</code> option.  Permissible names are: <code>armv2</code>,
<code>armv2a</code>, <code>armv3</code>, <code>armv3m</code>, <code>armv4</code>, <code>armv4t</code>,
<code>armv5</code>, <code>armv5t</code>, <code>armv5te</code>, <code>armv6</code>, <code>armv6j</code>,
<code>iwmmxt</code>, <code>ep9312</code>.

     <br><dt><code>-mfpu=</code><var>name</var><code></code>
     <dd><dt><code>-mfpe=</code><var>number</var><code></code>
     <dd><dt><code>-mfp=</code><var>number</var><code></code>
     <dd>This specifies what floating point hardware (or hardware emulation) is
available on the target.  Permissible names are: <code>fpa</code>, <code>fpe2</code>,
<code>fpe3</code>, <code>maverick</code>, <code>vfp</code>.  <code>-mfp</code> and <code>-mfpe</code>
are synonyms for <code>-mfpu</code>=<code>fpe</code><var>number</var>, for compatibility
with older versions of GCC.

     <p>If <code>-msoft-float</code> is specified this specifies the format of
floating point values.

     <br><dt><code>-mstructure-size-boundary=</code><var>n</var><code></code>
     <dd>The size of all structures and unions will be rounded up to a multiple
of the number of bits set by this option.  Permissible values are 8, 32
and 64.  The default value varies for different toolchains.  For the COFF
targeted toolchain the default value is 8.  A value of 64 is only allowed
if the underlying ABI supports it.

     <p>Specifying the larger number can produce faster, more efficient code, but
can also increase the size of the program.  Different values are potentially
incompatible.  Code compiled with one value cannot necessarily expect to
work with code or libraries compiled with another value, if they exchange
information using structures or unions.

     <br><dt><code>-mabort-on-noreturn</code>
     <dd>Generate a call to the function <code>abort</code> at the end of a
<code>noreturn</code> function.  It will be executed if the function tries to
return.

     <br><dt><code>-mlong-calls</code>
     <dd><dt><code>-mno-long-calls</code>
     <dd>Tells the compiler to perform function calls by first loading the
address of the function into a register and then performing a subroutine
call on this register.  This switch is needed if the target function
will lie outside of the 64 megabyte addressing range of the offset based
version of subroutine call instruction.

     <p>Even if this switch is enabled, not all function calls will be turned
into long calls.  The heuristic is that static functions, functions
which have the <code>short-call</code> attribute, functions that are inside
the scope of a <code>#pragma no_long_calls</code> directive and functions whose
definitions have already been compiled within the current compilation
unit, will not be turned into long calls.  The exception to this rule is
that weak function definitions, functions with the <code>long-call</code>
attribute or the <code>section</code> attribute, and functions that are within
the scope of a <code>#pragma long_calls</code> directive, will always be
turned into long calls.

     <p>This feature is not enabled by default.  Specifying
<code>-mno-long-calls</code> will restore the default behavior, as will
placing the function calls within the scope of a <code>#pragma
long_calls_off</code> directive.  Note these switches have no effect on how
the compiler generates code to handle function calls via function
pointers.

     <br><dt><code>-mnop-fun-dllimport</code>
     <dd>Disable support for the <code>dllimport</code> attribute.

     <br><dt><code>-msingle-pic-base</code>
     <dd>Treat the register used for PIC addressing as read-only, rather than
loading it in the prologue for each function.  The run-time system is
responsible for initializing this register with an appropriate value
before execution begins.

     <br><dt><code>-mpic-register=</code><var>reg</var><code></code>
     <dd>Specify the register to be used for PIC addressing.  The default is R10
unless stack-checking is enabled, when R9 is used.

     <br><dt><code>-mcirrus-fix-invalid-insns</code>
     <dd>Insert NOPs into the instruction stream to in order to work around
problems with invalid Maverick instruction combinations.  This option
is only valid if the <code>-mcpu=ep9312</code> option has been used to
enable generation of instructions for the Cirrus Maverick floating
point co-processor.  This option is not enabled by default, since the
problem is only present in older Maverick implementations.  The default
can be re-enabled by use of the <code>-mno-cirrus-fix-invalid-insns</code>
switch.

     <br><dt><code>-mpoke-function-name</code>
     <dd>Write the name of each function into the text section, directly
preceding the function prologue.  The generated code is similar to this:

     <pre class="smallexample">               t0
                   .ascii "arm_poke_function_name", 0
                   .align
               t1
                   .word 0xff000000 + (t1 - t0)
               arm_poke_function_name
                   mov     ip, sp
                   stmfd   sp!, {fp, ip, lr, pc}
                   sub     fp, ip, #4
          </pre>

     <p>When performing a stack backtrace, code can inspect the value of
<code>pc</code> stored at <code>fp + 0</code>.  If the trace function then looks at
location <code>pc - 12</code> and the top 8 bits are set, then we know that
there is a function name embedded immediately preceding this location
and has length <code>((pc[-3]) &amp; 0xff000000)</code>.

     <br><dt><code>-mthumb</code>
     <dd>Generate code for the 16-bit Thumb instruction set.  The default is to
use the 32-bit ARM instruction set.

     <br><dt><code>-mtpcs-frame</code>
     <dd>Generate a stack frame that is compliant with the Thumb Procedure Call
Standard for all non-leaf functions.  (A leaf function is one that does
not call any other functions.)  The default is <code>-mno-tpcs-frame</code>.

     <br><dt><code>-mtpcs-leaf-frame</code>
     <dd>Generate a stack frame that is compliant with the Thumb Procedure Call
Standard for all leaf functions.  (A leaf function is one that does
not call any other functions.)  The default is <code>-mno-apcs-leaf-frame</code>.

     <br><dt><code>-mcallee-super-interworking</code>
     <dd>Gives all externally visible functions in the file being compiled an ARM
instruction set header which switches to Thumb mode before executing the
rest of the function.  This allows these functions to be called from
non-interworking code.

     <br><dt><code>-mcaller-super-interworking</code>
     <dd>Allows calls via function pointers (including virtual functions) to
execute correctly regardless of whether the target code has been
compiled for interworking or not.  There is a small overhead in the cost
of executing a function pointer if this option is enabled.

   </dl>

   </body></html>

